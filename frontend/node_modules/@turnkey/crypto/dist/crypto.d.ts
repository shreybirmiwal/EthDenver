/// <reference lib="dom" />
interface DecryptExportBundleParams {
    exportBundle: string;
    organizationId: string;
    embeddedKey: string;
    dangerouslyOverrideSignerPublicKey?: string;
    returnMnemonic: boolean;
}
interface EncryptPrivateKeyToBundleParams {
    privateKey: string;
    keyFormat: string;
    importBundle: string;
    userId: string;
    organizationId: string;
    dangerouslyOverrideSignerPublicKey?: string;
}
interface EncryptWalletToBundleParams {
    mnemonic: string;
    importBundle: string;
    userId: string;
    organizationId: string;
    dangerouslyOverrideSignerPublicKey?: string;
}
interface HpkeDecryptParams {
    ciphertextBuf: Uint8Array;
    encappedKeyBuf: Uint8Array;
    receiverPriv: string;
}
interface HpkeEncryptParams {
    plainTextBuf: Uint8Array;
    targetKeyBuf: Uint8Array;
}
interface HpkeAuthEncryptParams {
    plainTextBuf: Uint8Array;
    targetKeyBuf: Uint8Array;
    senderPriv: string;
}
interface KeyPair {
    privateKey: string;
    publicKey: string;
    publicKeyUncompressed: string;
}
/**
 * Get PublicKey function
 * Derives public key from Uint8Array or hexstring private key
 *
 * @param {Uint8Array | string} privateKey - The Uint8Array or hexstring representation of a compressed private key.
 * @param {boolean} isCompressed - Specifies whether to return a compressed or uncompressed public key. Defaults to true.
 * @returns {Uint8Array} - The public key in Uin8Array representation.
 */
export declare const getPublicKey: (privateKey: Uint8Array | string, isCompressed?: boolean) => Uint8Array;
/**
 * HPKE Encrypt Function
 * Encrypts data using Hybrid Public Key Encryption (HPKE) standard https://datatracker.ietf.org/doc/rfc9180/.
 *
 * @param {HpkeEncryptParams} params - The encryption parameters including plain text, encapsulated key, and sender private key.
 * @returns {Uint8Array} - The encrypted data.
 */
export declare const hpkeEncrypt: ({ plainTextBuf, targetKeyBuf, }: HpkeEncryptParams) => Uint8Array;
/**
 * HPKE Encrypt Function
 * Encrypts data using Authenticated ,Hybrid Public Key Encryption (HPKE) standard https://datatracker.ietf.org/doc/rfc9180/.
 *
 * @param {HpkeAuthEncryptParams} params - The encryption parameters including plain text, encapsulated key, and sender private key.
 * @returns {Uint8Array} - The encrypted data.
 */
export declare const hpkeAuthEncrypt: ({ plainTextBuf, targetKeyBuf, senderPriv, }: HpkeAuthEncryptParams) => Uint8Array;
/**
 * Format HPKE Buffer Function
 * Returns a JSON string of an encrypted bundle, separating out the cipher text and the sender public key
 *
 * @param {Uint8Array} encryptedBuf - The result of hpkeAuthEncrypt or hpkeEncrypt
 * @returns {string} - A JSON string with "encappedPublic" and "ciphertext"
 */
export declare const formatHpkeBuf: (encryptedBuf: Uint8Array) => string;
/**
 * HPKE Decrypt Function
 * Decrypts data using Hybrid Public Key Encryption (HPKE) standard https://datatracker.ietf.org/doc/rfc9180/.
 *
 * @param {HpkeDecryptParams} params - The decryption parameters including ciphertext, encapsulated key, and receiver private key.
 * @returns {Uint8Array} - The decrypted data.
 */
export declare const hpkeDecrypt: ({ ciphertextBuf, encappedKeyBuf, receiverPriv, }: HpkeDecryptParams) => Uint8Array;
/**
 * Decrypt an encrypted email auth/recovery or oauth credential bundle.
 *
 * @param {string} credentialBundle - The encrypted credential bundle.
 * @param {string} embeddedKey - The private key for decryption.
 * @returns {string} - The decrypted data or null if decryption fails.
 * @throws {Error} - If unable to decrypt the credential bundle
 */
export declare const decryptCredentialBundle: (credentialBundle: string, embeddedKey: string) => string;
/**
 * Decrypt an encrypted export bundle (such as a private key or wallet account bundle).
 *
 * This function verifies the enclave signature to ensure the authenticity of the encrypted data.
 * It uses HPKE (Hybrid Public Key Encryption) to decrypt the contents of the bundle and returns
 * either the decrypted mnemonic or the decrypted data in hexadecimal format, based on the
 * `returnMnemonic` flag.
 *
 * @param {DecryptExportBundleParams} params - An object containing the following properties:
 *   - exportBundle {string}: The encrypted export bundle in JSON format.
 *   - organizationId {string}: The expected organization ID to verify against the signed data.
 *   - embeddedKey {string}: The private key used for decrypting the data.
 *   - dangerouslyOverrideSignerPublicKey {string} [Optional]: Optionally override the default signer public key used for verifying the signature. This should only be done for testing
 *   - returnMnemonic {boolean}: If true, returns the decrypted data as a mnemonic string; otherwise, returns it in hexadecimal format.
 * @returns {Promise<string>} - A promise that resolves to the decrypted mnemonic or decrypted hexadecimal data.
 * @throws {Error} - If decryption or signature verification fails, throws an error with details.
 */
export declare const decryptExportBundle: ({ exportBundle, embeddedKey, organizationId, dangerouslyOverrideSignerPublicKey, returnMnemonic, }: DecryptExportBundleParams) => Promise<string>;
/**
 * Generate a P-256 key pair. Contains the hexed privateKey, publicKey, and Uncompressed publicKey
 *
 * @returns {KeyPair} - The generated key pair.
 */
export declare const generateP256KeyPair: () => KeyPair;
/**
 * Create additional associated data (AAD) for AES-GCM decryption.
 *
 * @param {Uint8Array} senderPubBuf
 * @param {Uint8Array} receiverPubBuf
 * @return {Uint8Array} - The resulting concatenation of sender and receiver pubkeys.
 */
export declare const buildAdditionalAssociatedData: (senderPubBuf: Uint8Array, receiverPubBuf: Uint8Array) => Uint8Array;
/**
 * Accepts a private key Uint8Array in the PKCS8 format, and returns the encapsulated private key.
 *
 * @param {Uint8Array} privateKey - A PKCS#8 private key structured with the key data at a specific position. The actual key starts at byte 36 and is 32 bytes long.
 * @return {Uint8Array} - The private key.
 */
export declare const extractPrivateKeyFromPKCS8Bytes: (privateKey: Uint8Array) => Uint8Array;
/**
 * Accepts a public key Uint8Array, and returns a Uint8Array with the compressed version of the public key.
 *
 * @param {Uint8Array} rawPublicKey - The raw public key.
 * @return {Uint8Array} â€“ The compressed public key.
 */
export declare const compressRawPublicKey: (rawPublicKey: Uint8Array) => Uint8Array;
/**
 * Accepts a public key array buffer, and returns a buffer with the uncompressed version of the public key
 * @param {Uint8Array} rawPublicKey - The public key.
 * @return {Uint8Array} - The uncompressed public key.
 */
export declare const uncompressRawPublicKey: (rawPublicKey: Uint8Array) => Uint8Array;
/**
 * Encrypts a private key bundle using HPKE and verifies the enclave signature.
 *
 * @param {EncryptPrivateKeyToBundleParams} params - An object containing the private key, key format, bundle, user, and organization details. Optionally, you can override the default signer key (for testing purposes)
 * @returns {Promise<string>} - A promise that resolves to a JSON string representing the encrypted bundle.
 * @throws {Error} - If enclave signature verification or any other validation fails.
 */
export declare const encryptPrivateKeyToBundle: ({ privateKey, keyFormat, importBundle, userId, organizationId, dangerouslyOverrideSignerPublicKey, }: EncryptPrivateKeyToBundleParams) => Promise<string>;
/**
/**
 * Encrypts a mnemonic wallet bundle using HPKE and verifies the enclave signature.
 *
 * @param {EncryptWalletToBundleParams} params - An object containing the mnemonic, bundle, user, and organization details. Optionally, you can override the default signer key (for testing purposes).
 * @returns {Promise<string>} - A promise that resolves to a JSON string representing the encrypted wallet bundle.
 * @throws {Error} - If enclave signature verification or any other validation fails.
 */
export declare const encryptWalletToBundle: ({ mnemonic, importBundle, userId, organizationId, dangerouslyOverrideSignerPublicKey, }: EncryptWalletToBundleParams) => Promise<string>;
export {};
//# sourceMappingURL=crypto.d.ts.map
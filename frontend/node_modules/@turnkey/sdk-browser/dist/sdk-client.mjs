import { WebauthnStamper } from '@turnkey/webauthn-stamper';
import { IframeStamper } from '@turnkey/iframe-stamper';
import { getWebAuthnAttestation } from '@turnkey/http';
import { VERSION } from './__generated__/version.mjs';
import WindowWrapper from './__polyfills__/window.mjs';
import { TurnkeyRequestError } from './__types__/base.mjs';
import { TurnkeySDKClientBase } from './__generated__/sdk-client-base.mjs';
import { getStorageValue, StorageKeys, removeStorageValue, setStorageValue } from './storage.mjs';
import { generateRandomBuffer, base64UrlEncode, createEmbeddedAPIKey } from './utils.mjs';

const DEFAULT_SESSION_EXPIRATION = "900"; // default to 15 minutes
class TurnkeyBrowserSDK {
    constructor(config) {
        this.passkeyClient = (rpId) => {
            const targetRpId = rpId ?? this.config.rpId ?? WindowWrapper.location.hostname;
            if (!targetRpId) {
                throw new Error("Tried to initialize a passkey client with no rpId defined");
            }
            const webauthnStamper = new WebauthnStamper({
                rpId: targetRpId,
            });
            return new TurnkeyPasskeyClient({
                stamper: webauthnStamper,
                apiBaseUrl: this.config.apiBaseUrl,
                organizationId: this.config.defaultOrganizationId,
            });
        };
        this.iframeClient = async (params) => {
            if (!params.iframeUrl) {
                throw new Error("Tried to initialize iframeClient with no iframeUrl defined");
            }
            const TurnkeyIframeElementId = params.iframeElementId ?? "turnkey-default-iframe-element-id";
            const iframeStamper = new IframeStamper({
                iframeContainer: params.iframeContainer,
                iframeUrl: params.iframeUrl,
                iframeElementId: TurnkeyIframeElementId,
            });
            await iframeStamper.init();
            return new TurnkeyIframeClient({
                stamper: iframeStamper,
                apiBaseUrl: this.config.apiBaseUrl,
                organizationId: this.config.defaultOrganizationId,
            });
        };
        this.serverSign = async (methodName, params, serverSignUrl) => {
            const targetServerSignUrl = serverSignUrl ?? this.config.serverSignUrl;
            if (!targetServerSignUrl) {
                throw new Error("Tried to call serverSign with no serverSignUrl defined");
            }
            const stringifiedBody = JSON.stringify({
                methodName: methodName,
                params: params,
            });
            const response = await fetch(targetServerSignUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-Client-Version": VERSION,
                },
                body: stringifiedBody,
                redirect: "follow",
            });
            if (!response.ok) {
                let res;
                try {
                    res = await response.json();
                }
                catch (_) {
                    throw new Error(`${response.status} ${response.statusText}`);
                }
                throw new TurnkeyRequestError(res);
            }
            const data = await response.json();
            return data;
        };
        /**
         * If there is a valid, current user session, this will return a read-enabled TurnkeyBrowserClient that can make read requests to Turnkey without additional authentication. This is powered by a session header resulting from a prior successful `login` call.
         *
         * @returns {Promise<TurnkeyBrowserClient | undefined>}
         */
        this.currentUserSession = async () => {
            const currentUser = await this.getCurrentUser();
            if (!currentUser?.readOnlySession) {
                return;
            }
            if (currentUser?.readOnlySession?.sessionExpiry > Date.now()) {
                return new TurnkeyBrowserClient({
                    readOnlySession: currentUser?.readOnlySession?.session,
                    apiBaseUrl: this.config.apiBaseUrl,
                    organizationId: currentUser?.organization?.organizationId ??
                        this.config.defaultOrganizationId,
                });
            }
            else {
                this.logoutUser();
            }
            return;
        };
        /**
         * If there is a valid, current read-session, this will return an auth bundle and its expiration. This auth bundle can be used in conjunction with an iframeStamper to create a read + write session.
         *
         * @returns {Promise<ReadWriteSession | undefined>}
         */
        this.getReadWriteSession = async () => {
            const readWriteSession = await getStorageValue(StorageKeys.ReadWriteSession);
            if (readWriteSession) {
                if (readWriteSession.sessionExpiry > Date.now()) {
                    return readWriteSession;
                }
                else {
                    await removeStorageValue(StorageKeys.ReadWriteSession);
                }
            }
            return;
        };
        /**
         * Fetches an auth bundle stored in local storage.
         *
         * @returns {Promise<string | undefined>}
         */
        this.getAuthBundle = async () => {
            return await getStorageValue(StorageKeys.AuthBundle); // DEPRECATED
        };
        /**
         * Fetches the current user's organization details.
         *
         * @returns {Promise<SubOrganization | undefined>}
         */
        this.getCurrentSubOrganization = async () => {
            const currentUser = await this.getCurrentUser();
            return currentUser?.organization;
        };
        /**
         * Fetches the currently active user.
         *
         * @returns {Promise<User | undefined>}
         */
        this.getCurrentUser = async () => {
            return await getStorageValue(StorageKeys.CurrentUser);
        };
        /**
         * Clears out all data pertaining to a user session.
         *
         * @returns {Promise<boolean>}
         */
        this.logoutUser = async () => {
            await removeStorageValue(StorageKeys.AuthBundle); // DEPRECATED
            await removeStorageValue(StorageKeys.CurrentUser);
            await removeStorageValue(StorageKeys.ReadWriteSession);
            return true;
        };
        this.config = config;
    }
}
class TurnkeyBrowserClient extends TurnkeySDKClientBase {
    constructor(config) {
        super(config);
        this.login = async (config) => {
            const readOnlySessionResult = await this.createReadOnlySession(config || {});
            const org = {
                organizationId: readOnlySessionResult.organizationId,
                organizationName: readOnlySessionResult.organizationName,
            };
            const currentUser = {
                userId: readOnlySessionResult.userId,
                username: readOnlySessionResult.username,
                organization: org,
                readOnlySession: {
                    session: readOnlySessionResult.session,
                    sessionExpiry: Number(readOnlySessionResult.sessionExpiry),
                },
            };
            await setStorageValue(StorageKeys.CurrentUser, currentUser);
            return readOnlySessionResult;
        };
        /**
         * Creates a read-write session. This method infers the current user's organization ID and target userId. To be used in conjunction with an `iframeStamper`: the resulting session's credential bundle can be injected into an iframeStamper to create a session that enables both read and write requests.
         *
         * @param email
         * @param targetEmbeddedKey
         * @param expirationSeconds
         * @returns {Promise<SdkApiTypes.TCreateReadWriteSessionResponse>}
         */
        this.loginWithReadWriteSession = async (targetEmbeddedKey, expirationSeconds = DEFAULT_SESSION_EXPIRATION, userId) => {
            const readWriteSessionResult = await this.createReadWriteSession({
                targetPublicKey: targetEmbeddedKey,
                expirationSeconds,
                userId: userId,
            });
            // store auth bundle in local storage
            await setStorageValue(StorageKeys.ReadWriteSession, {
                authBundle: readWriteSessionResult.credentialBundle,
                sessionExpiry: Date.now() + Number(expirationSeconds) * 1000,
            });
            return readWriteSessionResult;
        };
    }
}
class TurnkeyPasskeyClient extends TurnkeyBrowserClient {
    constructor(config) {
        super(config);
        /**
         * Create a passkey for an end-user, taking care of various lower-level details.
         *
         * @returns {Promise<Passkey>}
         */
        this.createUserPasskey = async (config = {}) => {
            const challenge = generateRandomBuffer();
            const encodedChallenge = base64UrlEncode(challenge);
            const authenticatorUserId = generateRandomBuffer();
            // WebAuthn credential options options can be found here:
            // https://www.w3.org/TR/webauthn-2/#sctn-sample-registration
            //
            // All pubkey algorithms can be found here: https://www.iana.org/assignments/cose/cose.xhtml#algorithms
            // Turnkey only supports ES256 (-7) and RS256 (-257)
            //
            // The pubkey type only supports one value, "public-key"
            // See https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype for more details
            // TODO: consider un-nesting these config params
            const webauthnConfig = {
                publicKey: {
                    rp: {
                        id: config.publicKey?.rp?.id ?? this.rpId,
                        name: config.publicKey?.rp?.name ?? "",
                    },
                    challenge: config.publicKey?.challenge ?? challenge,
                    pubKeyCredParams: config.publicKey?.pubKeyCredParams ?? [
                        {
                            type: "public-key",
                            alg: -7,
                        },
                    ],
                    user: {
                        id: config.publicKey?.user?.id ?? authenticatorUserId,
                        name: config.publicKey?.user?.name ?? "Default User",
                        displayName: config.publicKey?.user?.displayName ?? "Default User",
                    },
                    authenticatorSelection: {
                        authenticatorAttachment: config.publicKey?.authenticatorSelection?.authenticatorAttachment ??
                            undefined,
                        requireResidentKey: config.publicKey?.authenticatorSelection?.requireResidentKey ??
                            true,
                        residentKey: config.publicKey?.authenticatorSelection?.residentKey ?? "required",
                        userVerification: config.publicKey?.authenticatorSelection?.userVerification ??
                            "preferred",
                    },
                },
            };
            const attestation = await getWebAuthnAttestation(webauthnConfig);
            return {
                encodedChallenge: config.publicKey?.challenge
                    ? base64UrlEncode(config.publicKey?.challenge)
                    : encodedChallenge,
                attestation,
            };
        };
        /**
         * Uses passkey authentication to create a read-write session, via an embedded API key, and stores + returns the resulting auth bundle that contains the encrypted API key. This auth bundle (also referred to as a credential bundle) can be injected into an iframeStamper, resulting in a touch-free authenticator. Unlike `loginWithReadWriteSession`, this method assumes the end-user's organization ID (i.e. the sub-organization ID) is already known.
         *
         * @param userId
         * @param targetEmbeddedKey
         * @param expirationSeconds
         * @param curveType
         * @returns {Promise<ReadWriteSession>}
         */
        this.createPasskeySession = async (userId, targetEmbeddedKey, expirationSeconds = DEFAULT_SESSION_EXPIRATION, organizationId) => {
            const localStorageUser = await getStorageValue(StorageKeys.CurrentUser);
            userId = userId ?? localStorageUser?.userId;
            const { authBundle, publicKey } = await createEmbeddedAPIKey(targetEmbeddedKey);
            // add API key to Turnkey User
            await this.createApiKeys({
                organizationId: organizationId,
                userId,
                apiKeys: [
                    {
                        apiKeyName: `Session Key ${String(Date.now())}`,
                        publicKey,
                        expirationSeconds,
                        curveType: "API_KEY_CURVE_P256",
                    },
                ],
            });
            const readWriteSession = {
                authBundle: authBundle,
                sessionExpiry: Date.now() + Number(expirationSeconds) * 1000,
            };
            // store auth bundle in local storage
            await setStorageValue(StorageKeys.ReadWriteSession, readWriteSession);
            return readWriteSession;
        };
        this.rpId = config.stamper.rpId;
    }
}
class TurnkeyIframeClient extends TurnkeyBrowserClient {
    constructor(config) {
        super(config);
        this.injectCredentialBundle = async (credentialBundle) => {
            const stamper = this.config.stamper;
            return await stamper.injectCredentialBundle(credentialBundle);
        };
        this.injectWalletExportBundle = async (credentialBundle, organizationId) => {
            const stamper = this.config.stamper;
            return await stamper.injectWalletExportBundle(credentialBundle, organizationId);
        };
        this.injectKeyExportBundle = async (credentialBundle, organizationId, keyFormat) => {
            const stamper = this.config.stamper;
            return await stamper.injectKeyExportBundle(credentialBundle, organizationId, keyFormat);
        };
        this.injectImportBundle = async (bundle, organizationId, userId) => {
            const stamper = this.config.stamper;
            return await stamper.injectImportBundle(bundle, organizationId, userId);
        };
        this.extractWalletEncryptedBundle = async () => {
            const stamper = this.config.stamper;
            return await stamper.extractWalletEncryptedBundle();
        };
        this.extractKeyEncryptedBundle = async () => {
            const stamper = this.config.stamper;
            return await stamper.extractKeyEncryptedBundle();
        };
        this.iframePublicKey = config.stamper.iframePublicKey;
    }
}

export { TurnkeyBrowserClient, TurnkeyBrowserSDK, TurnkeyIframeClient, TurnkeyPasskeyClient };
//# sourceMappingURL=sdk-client.mjs.map
